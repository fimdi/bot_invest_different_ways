const users = require('./data/users.json');
const data = require('./data/data.json');
const config = require('./config.json');
const utils = require('./utils.js');

const editCommand = require('./commands/–∫–æ–º–∞–Ω–¥–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.js');
const createCommand = require('./commands/–∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞—Ç—å.js');
const steal = require('./commands/_—Ñ—É–Ω–∫—Ü–∏—è –∫—Ä–∞–∂–∏.js');
const invest = require('./commands/_—Ñ—É–Ω–∫—Ü–∏—è –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.js');

const { VK, Keyboard } = require('vk-io');
const { QuestionManager } = require('vk-io-question');

const vk = new VK({
	token: config.group_token,
	pollingGroupId: config.group_id,
	apiMode: 'parallel_selected'
});
const startProfile = JSON.stringify({
	"name": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å",
	"balanceForWithdrawal": 0,
	"balanceForInvestment": 0,
	"invested": 0,
	"investmentMethod": null,
	"usedInvestmentMethods": [],
	"withdrawn": 0,
	"replenished": 0,
	"stolenFromUser": 0,
	"stolenByUser": 0,
	"attemptsSteal": 1,
	"ban": false
});

const questionManager = new QuestionManager();
vk.updates.use(questionManager.middleware);

vk.updates.on('message_new', async (context, next) => 
{
	if (!users[context.senderId]) 
	{
		let [userData] = await vk.api.users.get({user_id: context.senderId});
		users[context.senderId] = JSON.parse(startProfile);
		users[context.senderId].name = userData.first_name;
	}

	return next();
});

const DAY = 86400000;
function everyDay()
{
	let date = new Date();
	let tomorrow = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
	let day = Math.floor( (Date.now() - data.onlineDate) / DAY );

	if (day < 1) return setTimeout(everyDay, +tomorrow - Date.now())
	//

	for (user in users)
	{
		if( !users[user].attemptsSteal ) users[user].attemptsSteal = 1;

		if (users[user].investmentMethod != null) // –µ—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å—Ç—å —Å–ø–æ—Å–æ–± –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
		{
			let multiplier = (day > users[user].investmentMethod.daysLeft ? users[user].investmentMethod.daysLeft : day);
			let res = (users[user].invested * users[user].investmentMethod.incomeDayPercentage / 100) - users[user].investmentMethod.taxDayRubles;
			
			users[user].balanceForWithdrawal += res * multiplier;
			users[user].investmentMethod.daysLeft -= multiplier;
		}
	}

	//
	data.onlineDate = Number( new Date(date.getFullYear(), date.getMonth(), date.getDate()) );
	setTimeout(everyDay, DAY);
}
everyDay();

const commands = [
	{
		regexp: /^–ù–∞—á–∞—Ç—å|Start|–°—Ç–∞—Ä—Ç|–ú–µ–Ω—é|–ó–∞–ø—É—Å–∫|–ü—Ä–∏–≤–µ—Ç|–•–∞–π|–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ|Hello$/i,
		function: require('./commands/–º–µ–Ω—é.js')
	},
	{
		regexp: /^üñ•–ü—Ä–æ—Ñ–∏–ª—å|–ü—Ä–æ—Ñ–∏–ª—å$/i,
		function: require('./commands/–ø—Ä–æ—Ñ–∏–ª—å.js')
	},
	{
		regexp: /^üìë–ò–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å|–ò–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å$/i,
		function: require('./commands/–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å.js')
	},
	{
		regexp: /^üñê–£–∫—Ä–∞—Å—Ç—å|–£–∫—Ä–∞—Å—Ç—å$/i,
		function: require('./commands/—É–∫—Ä–∞—Å—Ç—å.js')
	},
	{
		regexp: /^‚¨á–ü–æ–ø–æ–ª–Ω–∏—Ç—å|–ü–æ–ø–æ–ª–Ω–∏—Ç—å$/i,
		function: require('./commands/–ø–æ–ø–æ–ª–Ω–∏—Ç—å.js')
	},
	{
		regexp: /^‚¨Ü–í—ã–≤–µ—Å—Ç–∏|–í—ã–≤–µ—Å—Ç–∏$/i,
		function: require('./commands/–≤—ã–≤–µ—Å—Ç–∏.js')
	},
	{
		regexp: /^üëÄ–¢–æ–ø|–¢–æ–ø$/i,
		function: require('./commands/—Ç–æ–ø.js')
	},
	{
		regexp: /^üí∞–ú–∞–≥–Ω–∞—Ç—ã$/i,
		function: require('./commands/—Ç–æ–ø –±–∞–ª–∞–Ω—Å –¥–ª—è –≤—ã–≤–æ–¥–∞.js')
	},
	{
		regexp: /^üñê–í–æ—Ä—ã$/i,
		function: require('./commands/—Ç–æ–ø –≤–æ—Ä–æ–≤.js')
	},
	{
		regexp: /^üï∏–ñ–µ—Ä—Ç–≤—ã –≤–æ—Ä–æ–≤$/i,
		function: require('./commands/—Ç–æ–ø –∂–µ—Ä—Ç–≤ –≤–æ—Ä–æ–≤.js')
	},
	{
		regexp: /^‚è≥–ò–Ω–≤–µ—Å—Ç–æ—Ä—ã$/i,
		function: require('./commands/—Ç–æ–ø –∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤.js')
	},
	{
		regexp: /^–í—Ä—É—á–Ω—É—é$/i,
		function: require('./commands/–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∏ –≤—ã–≤–æ–¥ –≤—Ä—É—á–Ω—É—é.js')
	},
	{
		regexp: /^–ö–µ–∫—Å–∏–∫$/i,
		function: require('./commands/–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–µ–∫—Å–∏–∫–æ–º.js'),
		payload: "–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ"
	},
	{
		regexp: /^–ÆMoney$/i,
		function: require('./commands/–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –ÆMoney.js'),
		payload: "–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ"
	},
	{
		regexp: /^–ÆMoney$/i,
		function: require('./commands/–≤—ã–≤–æ–¥ –ÆMoney.js'),
		payload: "–≤—ã–≤–æ–¥"
	}
];

let cache = {};

vk.updates.on('message_new', async (context) => 
{
	if (context.senderId in cache)
	{
		context.state.user = cache[context.senderId];
		delete cache[context.senderId];
	}
	
	let text = context.text;
	let arr = text.split(" ");

	if ( config.owners.includes(context.senderId) )
	{
		if ( /^—Ä–µ–¥$/i.test(arr[0]) ) return editCommand(context, arr, users, startProfile, vk);
		if ( /^—Å–æ–∑–¥–∞—Ç—å$/i.test(arr[0]) ) return createCommand(context, arr, users, startProfile, vk);
	}
	
	if ( !isNaN(text) ) // –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–ø—Ä–∞–≤–∏–ª —á–∏—Å–ª–æ
	{
		if ( context.state.user?.pastMessage == "–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å" ) return invest(context, users, data);
		if ( context.state.user?.pastMessage == "—É–∫—Ä–∞—Å—Ç—å" ) return steal(context, users, data, vk);
	};

	let indexInCommands = 
	commands.findIndex(command => command.regexp.test(text) && 
								  context.messagePayload?.command == command.payload); // –∏–Ω–¥–µ–∫—Å –∫–æ–º–∞–Ω–¥—ã
	
	if ( indexInCommands == -1 )
	{
		return context.send("–¢–∞–∫–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–µ—Ç",
		{
			keyboard: Keyboard.builder()
			.textButton({
				label: '–ú–µ–Ω—é',
				color: Keyboard.SECONDARY_COLOR
			})
			.inline()
		});
	}

	commands[indexInCommands].function(context, users, data); 

	// –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ "–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å"
	if ( indexInCommands == 2 ) cache[context.senderId] = { pastMessage: "–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å" }
	// –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ "—É–∫—Ä–∞—Å—Ç—å"
	if ( indexInCommands == 3 ) cache[context.senderId] = { pastMessage: "—É–∫—Ä–∞—Å—Ç—å" }
});

setInterval(() =>
{
    utils.save('./data/data.json', data);
    utils.save('./data/users.json', users);
}, 3000);

async function run() 
{
    await vk.updates.start();
    console.log("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!");
}
run().catch(console.error);